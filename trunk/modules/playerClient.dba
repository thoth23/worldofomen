REM *** Include File: modules\playerShared.dba ***
REM Created: 7/4/2010 11:07:28 AM
REM
REM Included in Project: C:\Program Files\The Game Creators\Dark Basic Professional\Projects\worldofomen\worldofomen.dbpro
REM

playerClientSetup:

   global idxPlayer as integer
   REM THIS IS THE DATAOBJECT ARRAY INDEX
   REM FOR THE LOCAL PLAYER OBJECT

   global playerMoveX as float
   global playerMoveZ as float
   global playerJumping as boolean

   global PLAYER_MOVE_PRECISION as float
   PLAYER_MOVE_PRECISION = floatval(dataSharedGetField("playerClient", "playerMovePrecision", "0.25", DATA_CREATE))

   global PLAYER_CURVE_SPEED as float
   PLAYER_CURVE_SPEED = floatval(dataSharedGetField("playerClient", "playerCurveSpeed", "1.0", DATA_CREATE))

   global PLAYER_JUMP_VELOCITY as float
   PLAYER_JUMP_VELOCITY = floatval(dataSharedGetField("playerClient", "playerJumpVelocity", "40.0", DATA_CREATE))

   REM INERTIA MUST ALWAYS BE LESS THAN MOVEMENT PRECISION
   global PLAYER_MAX_INERTIA as float
   PLAYER_MAX_INERTIA = floatval(dataSharedGetField("playerClient", "playerMaxInertia", "0.10", DATA_CREATE))

   #constant PLAYER_PATH "media/avatar/"
   global PLAYER_DEFAULT_MESH as string
   PLAYER_DEFAULT_MESH = dataSharedGetField("playerClient", "playerDefaultMesh", "player_base.dbo",1)

   #constant PLAYER_FUNCTION_FAIL 0
   #constant PLAYER_FUNCTION_OK 1

return

function playerObjectExist(idx as integer)

   local retval as boolean
   retval = PLAYER_FUNCTION_FAIL

   REM ARRAY INDEX MUST BE VALID
   if idx > 0 and idx <= array count(dataObject())
      REM DBPRO ID MUST BE VALID
      if dataObject(idx).dbpid > 0
         if object exist(dataObject(idx).dbpid) then retval = PLAYER_FUNCTION_OK
      endif
   endif

endfunction retval

function playerClientCreate(rpgid as integer, dbpid as integer)

   local mydbpid as integer

   idx = dataSharedGetFree(DATA_SEARCH_REUSE)
   debugWrite(DEBUGINFO,"playerClientCreate: idx found " + str$(idx))

   if idx > 0
      mydbpid = dataSharedSetKeys(idx, rpgid, dbpid)
      if mydbpid > 0

         REM THIS SECTION WILL BE MOVED OVER
         REM TO THE MESHCLIENT MODULE SOON

         if file exist(PLAYER_PATH + PLAYER_DEFAULT_MESH)

            datafilename$ = PLAYER_PATH + PLAYER_DEFAULT_MESH + DATA_FILE_EXT

            if file exist(datafilename$)

               REM MESH HAS ITS OWN DATA FILE
               REM LOAD TABLE IF NOT ALREADY LOADED
               if dataSharedTableExist(datafilename$) = DATA_FUNCTION_FAIL
                  debugWrite(DEBUGINFO,"playerClientCreate: attempting to load data file: " + datafilename$)
                  dataSharedLoadTable(datafilename$,datafilename$)
               endif

               REM APPLY THE DATA FILE TO THE ASSOCIATED
               REM DATAOBJECT ARRAY
               dataSharedApply(datafilename$, idx)

            endif

            load object PLAYER_PATH + PLAYER_DEFAULT_MESH,mydbpid,1
            debugWrite(DEBUGINFO,"playerClientCreate player height " + str$(object size y(mydbpid)))
            position object mydbpid, dataObject(idx).posx,dataObject(idx).posy,dataObject(idx).posz
            REM ONLY SCALE WHEN NECESSARY
            if dataObject(idx).sclx <> 1 or dataObject(idx).scly <> 1 or dataObject(idx).sclz <> 1
               scale object mydbpid, (dataObject(idx).sclx * 100.0),(dataObject(idx).scly * 100.0),(dataObject(idx).sclz * 100.0)
            endif
            collisionClientSet(mydbpid,dataObject(idx).collisionType,dataObject(idx).collisionGroup)

         else
            debugWrite(DEBUGERROR,"playerClientCreate: file not found " + PLAYER_PATH + PLAYER_DEFAULT_MESH)
         endif
      else
         debugWrite(DEBUGERROR,"playerClientCreate: array index returned " + str$(idx) + " invalid from dataSharedSetKeys")
      endif
   else
      debugWrite(DEBUGERROR,"playerClientCreate: Failed to find free object from dataSharedGetFree")
   endif

endfunction idx

function playerClientDestroy(rpgid as integer)

   local mydbpid as integer
   local idx as integer
   local retval as boolean
   retval = PLAYER_FUNCTION_FAIL

   idx = playerSharedGetIndex(rpgid)
   if idx > 0
      mydbpid = dataObject(idx).dbpid
      if mydbpid > 0
         if object exist(mydbpid)
            delete object mydbpid
            retval = PLAYER_FUNCTION_OK
         else
            debugWrite(DEBUGWARN,"playerClientDestory: player " + str$(rpgid) + " had valid dbpid " + str$(mydbpid) + " but no object.")
         endif
      else
         debugWrite(DEBUGWARN,"playerClientDestory: player " + str$(rpgid) + " had dbpid with value 0")
      endif
   else
   endif

endfunction retval

function playerClientControl()

   local mytableid as integer
   local myidx as integer
   local mydbpid as integer
   local dist# as float
   local x# as float
   local y# as float
   local z# as float

   REM NOW WE'RE GOING TO GO THROUGH THE LIST OF
   REM PLAYERS WE ARE AWARE OF AND UPDATE EACH ONE

   mytableid = dataSharedTableExist(DATA_TABLE_PIDX)
   if mytableid > 0
      FIRST LOOKUP mytableid
      while lookup is valid(mytableid)
         if LOOKUP CURRENT KEY$(mytableid) <> "" AND LOOKUP CURRENT KEY$(mytableid) <> DATA_KEY_DIRTY
            myidx = intval(LOOKUP CURRENT VALUE$(mytableid))

            if playerObjectExist(myidx) = PLAYER_FUNCTION_OK

               mydbpid = dataObject(myidx).dbpid

               REM IF PLAYER IS NOT MOVING, AND GRAVITY IS ON FOR PLAYER
               REM THEN APPLY SIMPLE GRAVITY
               if dataObject(myidx).gravity <> 0 AND dataObject(myidx).velxz <= 0.0
                  x# = object position x(mydbpid)
                  y# = object position y(mydbpid)
                  z# = object position z(mydbpid)
                  dataObject(myidx).ground = collisionClientFall(mydbpid,COLLISIONGROUPWORLD,x#,y#,z#,x#,y#,z#,1)
               endif

               REM IF PLAYER HAS POSITIVE Y VELOCITY
               REM THEN REGULATE JUMPING
               if dataObject(myidx).vely > 0.0
                  move object up mydbpid, systemSharedFrameMoved(dataObject(myidx).vely)
                  dataObject(myidx).vely = dataObject(myidx).vely - systemSharedFrameMoved((dataObject(myidx).veljump * 0.5))
                  dataObject(myidx).vely = max(0.0, dataObject(myidx).vely)
               endif

               if myidx = idxPlayer
                  REM REGULATE LOCAL PLAYER
                  playerClientControlLocal(myidx)
               else
                  REM REGULATE REMOTE PLAYERS
                  playerClientControlRemote(myidx)
               endif

              REM MAINTAIN PITCH AND ROLL AT 0 WHEN NOT FLYING
               if dataObject(myidx).gravity <> 0
                  rotate object mydbpid, 0.0, object angle y(mydbpid), 0.0
               endif

            endif

         endif

         NEXT LOOKUP mytableid

      endwhile
   endif

endfunction

function playerClientControlLocal(idx as integer)

   local mydbpid as integer

   mydbpid = dataObject(idx).dbpid

   if playerMoveX = 0 AND playerMoveZ = 0

      REM PLAYER DID NOT MOVE
      dataObject(idx).velxz = 0.0

   else

      REM PLAYER DID MOVE

      dataObject(idx).velxz = systemSharedFrameMoved(dataObject(idx).speed)

      netUpdateMode = 1

      oldx# = object position x(mydbpid)
      oldy# = object position y(mydbpid)
      oldz# = object position z(mydbpid)

      move object mydbpid, (dataObject(idx).velxz * playerMoveZ)
      move object left mydbpid, (dataObject(idx).velxz * playerMoveX)

      x# = object position x(mydbpid)
      y# = object position y(mydbpid)
      z# = object position z(mydbpid)

      REM APPLY GRAVITY AND SLIDING COLLISION
      dataObject(idx).ground = collisionClientSlide(mydbpid,COLLISIONGROUPWORLD,oldx#,oldy#,oldz#,x#,y#,z#,1)

   endif

   REM NOW LETS SEE IF THE PLAYER IS TRYING TO
   REM JUMP AND IF SO, SEE IF JUMP IS VALID
   REM AND IF SO, THEN START JUMP
   if playerJumping = 1
      if dataObject(idx).ground = 1
         dataObject(idx).vely = dataObject(idx).veljump
         REM IMMEDIATELY SEND A JUMP PACKET
         `netClientJump()
         rem not yet
      endif
   endif


endfunction


function playerClientControlRemote(idx as integer)

   local mydbpid as integer
   local distCategory as integer
   local deltaVelocity as float
   local tempy as float

   mydbpid = dataObject(idx).dbpid

   REM REGULATE MOVEMENT
   dist# = systemSharedGetDistance3D(dataObject(idx).posx,dataObject(idx).posy,dataObject(idx).posz,object position x(mydbpid),object position y(mydbpid),object position z(mydbpid))
   distCategory = int(dist#/PLAYER_MOVE_PRECISION)
   deltaVelocity = systemSharedFrameMoved(dataObject(idx).speed)
   oldx# = object position x(mydbpid)
   oldy# = object position y(mydbpid)
   oldz# = object position z(mydbpid)

   REM MOVE

   select distCategory
      case 0
         REM LESS THAN MOVE PRECISION
         dataObject(idx).velxz = 0
      endcase
      case 1
         REM BETWEEN 1x AND 2x MOVE PRECISION

         REM START SLOWING DOWN OVER 1 SECOND
         if dataObject(idx).velxz > 0
            dataObject(idx).velxz = max(dataObject(idx).velxz - deltaVelocity,0)
         endif

         point object mydbpid, dataObject(idx).posx,dataObject(idx).posy,dataObject(idx).posz
         move object mydbpid, systemSharedFrameMoved(dataObject(idx).velxz)

      endcase
      case default
         REM GREATER THAN 3x MOVE PRECISION

         if dataObject(idx).velxz < dataObject(idx).speed
            REM START SPEEDING UP OVER 1 SECOND
            dataObject(idx).velxz = min(dataObject(idx).velxz + deltaVelocity,dataObject(idx).speed)
         endif

         REM THE LARGER THE CURVEANGLE SPEED VALUE, THE MORE PRECISION, THE SMALLER THE CHANGE PER FRAME
         starty = object angle y(mydbpid)
         point object mydbpid, dataObject(idx).posx,dataObject(idx).posy,dataObject(idx).posz
         endy = object angle y(mydbpid)
         rotate object mydbpid, object angle x(mydbpid),curveangle(starty, endy, systemGameFPS),object angle z(mydbpid)

         move object mydbpid, systemSharedFrameMoved(dataObject(idx).velxz)

      endcase
   endselect

   REM HANDLE COLLISION IF MOVING
   if distCategory > 0
         x# = object position x(mydbpid)
         y# = object position y(mydbpid)
         z# = object position z(mydbpid)
         dataObject(idx).ground = collisionClientSlide(mydbpid,COLLISIONGROUPWORLD,oldx#,oldy#,oldz#,x#,y#,z#,1)
   endif

endfunction


function playerClientRotateY(mydbpid as integer, angle# as float)

   if mydbpid > 0
      if object exist(mydbpid)
         rotate object mydbpid, 0.0, angle#, 0.0
      endif
   endif

endfunction
