REM *** Include File: modules\dataShared.dba ***
REM Created: 7/4/2010 10:46:45 AM
REM
REM Included in Project: C:\Program Files\The Game Creators\Dark Basic Professional\Projects\worldofomen\worldofomen.dbpro
REM

dataSharedSetup:

   #constant DATA_FUNCTION_FAIL -1
   #constant DATA_FUNCTION_OK 1
   #constant DATA_KEY_DIRTY "dirty"
   #constant DATA_DIRTY 1
   #constant DATA_CLEAN 0
      
   #constant DATA_NO_CREATE   0
   #constant DATA_CREATE      1
   #constant DATA_NO_REVERSE 0
   #constant DATA_REVERSE 1
   
   #constant DATA_REVERSE_SUFFIX "_REVERSE"

   #constant DATA_SEARCH_FAST    1
   #constant DATA_SEARCH_REUSE   2

   #constant DATA_KEY_UNDEFINED     "\\\undefined\\\"
   #constant DATA_KEY_HIDDEN        "\\\hidden\\\"
   #constant DATA_KEY_NOSAVE        "\\\nosave\\\"
   #constant DATA_ARGSEP            ";"
   #constant DATA_NAMEVALSEP        "="
   #constant DATA_FILE_EXT          ".ini"
   #constant DATA_TEMPLATE_KEY      "inherit"

   global DATA_NOSAVE_TABLES as string
   global DATA_LANGUAGE as string

   REM BASE TABLE MUST BE BUILT MANUALLY
   #constant DATA_TABLES            100
   #constant DATA_TNAME_TABLES      "tables"
   make lookup DATA_TABLES
   set lookup DATA_TABLES, DATA_TNAME_TABLES, str$(DATA_TABLES)
   systemSharedPushFree(SYSTEM_TYPE_LOOKUP,100)
   debugWrite(DEBUGINFO,"ROOT table is " + DATA_TNAME_TABLES + " with tableid: " + str$(DATA_TABLES))
   dataSharedRegisterNoSaveTable(DATA_TNAME_TABLES)
   
   REM PRE-BUILD THE INPUT TABLE
   #constant DATA_TABLE_INPUT "input"
   dataSharedMakeTable(DATA_TABLE_INPUT,0,DATA_NO_REVERSE)
   dataSharedRegisterNoSaveTable(DATA_TABLE_INPUT)

   REM PRE-BUILD THE GUI TABLE
   #constant DATA_TABLE_GUI "gui"
   dataSharedMakeTable(DATA_TABLE_GUI,0,DATA_NO_REVERSE)
   
   REM PRE-BUILD THE GUIDATA TABLE
   #constant DATA_TABLE_GUIDATA "guidata"
   dataSharedMakeTable(DATA_TABLE_GUIDATA,0,DATA_NO_REVERSE)
   dataSharedRegisterNoSaveTable(DATA_TABLE_GUIDATA)

   REM PRE-BUILD THE LIBRARY TABLE
   #constant DATA_TABLE_LIBRARY "library"
   dataSharedMakeTable(DATA_TABLE_LIBRARY,0,DATA_REVERSE)   
   
   REM PRE-BUILD THE ASSETS TABLE
   #constant DATA_TABLE_ASSETS "assets"
   dataSharedMakeTable(DATA_TABLE_ASSETS,0,DATA_NO_REVERSE)   
   dataSharedRegisterNoSaveTable(DATA_TABLE_ASSETS)


return

function dataSharedRegisterNoSaveTable(tableName$ as string)
   DATA_NOSAVE_TABLES = systemSharedFieldAdd(DATA_NOSAVE_TABLES,tableName$,DATA_ARGSEP)
endfunction

function dataSharedMakeTable(tableName$ as string, tableid as integer, makeReverse as boolean)
   
   if tableid = 0 then tableid = systemSharedGetFree(SYSTEM_TYPE_LOOKUP,SYSTEM_SEARCH_FAST)
   make lookup tableid
   set lookup DATA_TABLES, tableName$, str$(tableid)
   dataSharedUpdateFieldFast(tableid, "tablename", tableName$)
   debugWrite(DEBUGINFO,"New table " + str$(tableid)  + ". " + tableName$)
   
   if makeReverse = 1
      rtableid = systemSharedGetFree(SYSTEM_TYPE_LOOKUP,SYSTEM_SEARCH_FAST)
      make lookup rtableid
      set lookup DATA_TABLES, tableName$ + DATA_REVERSE_SUFFIX, str$(rtableid)
      dataSharedUpdateFieldFast(rtableid, "tablename", tableName$ + DATA_REVERSE_SUFFIX)
      debugWrite(DEBUGINFO,"New table " + str$(rtableid) + ". " + tableName$ + DATA_REVERSE_SUFFIX)
      REM REVERSE LOOKUPS ARE NEVER SAVED
      dataSharedRegisterNoSaveTable(tableName$ + DATA_REVERSE_SUFFIX)
   endif

endfunction tableid

function dataSharedGetLibraryPath(rpgid as integer)

   local retval$ as string

   retval$ = dataSharedGetField(DATA_TABLE_LIBRARY, str$(rpgid), DATA_KEY_UNDEFINED, DATA_NO_CREATE)
   if retval$ = DATA_KEY_UNDEFINED
      debugWrite(DEBUGWARN,"dataSharedGetLibraryPath: AssetID Not Found " + str$(rpgidAsset))
   endif

endfunction retval$

function dataSharedGetAssetID(rpgid as integer)

   local retval$ as string
   local retval as integer

   retval$ = dataSharedGetField(DATA_TABLE_ASSETS,str$(rpgid), DATA_KEY_UNDEFINED, DATA_NO_CREATE)
   if retval$ = DATA_KEY_UNDEFINED

      myPath$ = dataSharedGetLibraryPath(rpgid)

      REM IF ASSET IS WHERE IT IS SUPPOSED
      REM TO BE THEN LOAD IT
      if file exist(myPath$)
         if fast right$(myPath$,2) = ".x"
            ext$ = "dbo"
         else
            ext$ = fast right$(myPath$,3)
         endif
         select ext$
            case "dbo"
               mydbpid = systemSharedGetFree(SYSTEM_TYPE_OBJECT, SYSTEM_SEARCH_REUSE)
               meshClientLoad(myPath$,mydbpid)
               dataSharedUpdateField(DATA_TABLE_ASSETS, str$(rpgid), str$(mydbpid))
               retval = mydbpid
            endcase
            case "tgt"
               mybnkid = systemSharedGetFree(SYSTEM_TYPE_BANK, SYSTEM_SEARCH_REUSE)
               meshClientLoadMorph(myPath$,mybnkid)
               dataSharedUpdateField(DATA_TABLE_ASSETS, str$(rpgid), str$(mybnkid))
               retval = mybnkid
            endcase
         endselect
      else
         debugWrite(DEBUGWARN,"dataSharedGetAssetID: Invalid Asset Path " + myPath$)
      endif
   else
      retval = intval(retval$)
   endif

endfunction retval

function dataSharedParse(tableName$ as string, attributes$ as string)

      REM PARSE A SPACE-DELIMITED ATTRIBUTE LIST
      REM AND APPY IT TO A TABLE

      split string attributes$, " "
      local dim dat$(split count())
      for i = 1 to split count()
         dat$(i) = get split word$(i)
      next
      for i = 1 to array count(dat$())
         split string dat$(i), "="
         key$ = get split word$(1)
         value$ = get split word$(2)
         dataSharedUpdateField(tableName$, key$, value$)
      next
      
      dataSharedUpdateField(tableName$, DATA_KEY_DIRTY, str$(DATA_DIRTY))
      
      undim dat$()

endfunction


function dataSharedCopyTable(sourceTableid as integer, targetTableid as integer)

   REM COPY ALL THE ATTRIBUTES
   REM FOR ONE TABLE INTO ANOTHER
   REM TABLE - USED TO APPLY TEMPLATES
   REM TO INSTANCES

   local retval as integer
   retval = DATA_FUNCTION_OK

   if sourceTableid = DATA_FUNCTION_FAIL then exitfunction DATA_FUNCTION_FAIL
   if targetTableid = DATA_FUNCTION_FAIL then exitfunction DATA_FUNCTION_FAIL
   
   first lookup sourceTableid
   while lookup is valid(sourceTableid)
      key$ = fast lower$(lookup current key$(sourceTableid))
      value$ = lookup current value$(sourceTableid)
      if key$ <> "tablename"
         dataSharedUpdateFieldFast(targetTableid, key$, value$)
      endif
      next lookup sourceTableid
   endwhile

   set lookup targetTableid, DATA_KEY_DIRTY, str$(DATA_DIRTY)
   
endfunction retval

function dataSharedResetTable(tableid as integer)
   
      REM FIRST GET THE TABLE NAME
      REM AND THE REVERSE TABLE NAME
      tableName$ = dataSharedGetFieldFast(tableid,"tablename")
      rTableName$ = tableName$ + DATA_REVERSE_SUFFIX
      rtableid = dataSharedTableExist(rTableName$)
      
      REM DELETE THE TABLE IF IT EXISTS
      if lookup exist(tableid)
         delete lookup tableid
         debugWrite(DEBUGINFO,"Deleted  Table " + str$(tableid) + ". " + tableName$)
      endif
      
      REM DELETE THE REVERSE TABLE IF IT EXISTS
      if lookup exist(rtableid)
         delete lookup rtableid
         debugWrite(DEBUGINFO,"Deleted rTable " + str$(rtableid) + ". " + rTableName$)
      endif
      
      REM REMOVE RECORD FROM DATA_TABLES
      if search lookup (DATA_TABLES, tableName$) = 1
         delete lookup DATA_TABLES, tableName$
      endif
      
      REM REMOVE RECORD FOR REVERSE TABLE FROM DATA_TABLES
      if search lookup (DATA_TABLES, rTableName$) = 1
         delete lookup DATA_TABLES, rTableName$
      endif
   
endfunction

function dataSharedDeleteRecord(tableid as integer, key$ as string)

      delete lookup tableid, key$
      
endfunction


function dataSharedGetField(tableName$, key$, default$,createFlag as boolean)

   local retval$ as string
   retval$ = DATA_KEY_UNDEFINED

   rem first find the tableID
   if search lookup (DATA_TABLES, tableName$) = 1
      if lookup is valid(DATA_TABLES)
         tableid = intval(lookup current value$(DATA_TABLES))
         rem now find the key/value pair in the right table
         if search lookup(tableid, key$) = 1
            if lookup is valid(tableid)
               retval$ = lookup current value$(tableid)
            else
               debugWrite(DEBUGWARN,"dataSharedGetField lookup invalid for table: " + str$(tableid))
            endif
         else
            if createFlag = 1
               dataSharedUpdateField(tableName$,key$,default$)
            endif
            retval$ = default$
         endif
      else
         debugWrite(DEBUGWARN,"dataSharedGetField table lookup invalid for table: " + tableName$)
      endif
   else
      if createFlag = 1
         tableid = dataSharedMakeTable(tableName$, 0, DATA_NO_REVERSE)
         set lookup tableid, key$, default$
         set lookup tableid, DATA_KEY_DIRTY, str$(DATA_DIRTY)
      endif
      retval$ = default$
   endif

endfunction retval$

function dataSharedGetFieldFast(tableid, key$)
   
   local retval$ as string
   retval$ = DATA_KEY_UNDEFINED
   
   if tableid > 0
      if search lookup(tableid, key$) = 1
            if lookup is valid(tableid)
               retval$ = lookup current value$(tableid)
            endif      
      endif
   endif
   
endfunction retval$

function dataSharedUpdateFieldFast(tableid as integer, key$, value$)

   if lookup exist(tableid) = 0
      tableid = dataSharedMakeTable(str$(tableid), tableid, DATA_NO_REVERSE)
   endif
   
   set lookup tableid, key$, value$
   set lookup tableid, DATA_KEY_DIRTY, str$(DATA_DIRTY)
      
endfunction



function dataSharedUpdateField(tableName$, key$, value$)

   REM THIS IS THE ONLY TABLE UPDATE FUNCTION
   REM THAT WILL AUTOMATICALY UPDATE 
   REM REVERSE LOOKUP TABLES
   
   local tableid as integer

   if tableName$ = "" then exitfunction DATA_FUNCTION_FAIL
   
   tableid = dataSharedTableExist(tableName$)
   if tableid = DATA_FUNCTION_FAIL
      tableid = dataSharedMakeTable(tableName$, 0, DATA_NO_REVERSE)
   endif      
   
   rem now set the key/value pair in the table
   set lookup tableid, key$, value$
   set lookup tableid, DATA_KEY_DIRTY, str$(DATA_DIRTY)
   
   rem now set the VALUE/KEY pair in the reverse table
   rtableid = dataSharedTableExist(tableName$ + DATA_REVERSE_SUFFIX)
   if rtableid <> DATA_FUNCTION_FAIL
      set lookup rtableid, value$, key$
      rem reverse lookups are never saved, so no need to set the DATA_KEY_DIRTY flag
      rem reverse lookups are never automatically created, must be created using the DATA_REVERSE flag when building a table
   endif

endfunction tableid

function dataSharedLoadAllTables()

   filename$ = DATA_PATH + DATA_TNAME_TABLES + DATA_FILE_EXT
   if file exist(filename$)
      open to read SYSTEM_FILE_TABLE, filename$
         while not file end(SYSTEM_FILE_TABLE)
            read string SYSTEM_FILE_TABLE, table$
            filename$ = DATA_PATH + table$ + DATA_FILE_EXT
            dataSharedLoadTable(filename$, table$)
         endwhile
      close file SYSTEM_FILE_TABLE
   endif

   DATA_LANGUAGE = dataSharedGetField(DATA_TABLE_GUI, "language", "language/english",DATA_CREATE)
   
   REM LOCALIZATION
   filename$ = DATA_PATH + DATA_LANGUAGE + DATA_FILE_EXT
   if file exist(filename$)
      open to read SYSTEM_FILE_DATA, filename$
      while not file end(SYSTEM_FILE_DATA)
         read string SYSTEM_FILE_DATA, dat$
         split string dat$,DATA_NAMEVALSEP
         dataSharedUpdateField(DATA_LANGUAGE, get split word$(1), get split word$(2))
      endwhile
      close file SYSTEM_FILE_DATA
   endif
   
   dataSharedRegisterNoSaveTable(DATA_LANGUAGE)

endfunction

function dataSharedLoadTable(filename$, table$)
   
   retval = DATA_FUNCTION_FAIL

   if file exist(filename$)
      
      retval = DATA_FUNCTION_OK

      REM LOAD BASE

      open to read SYSTEM_FILE_DATA, filename$
      while not file end(SYSTEM_FILE_DATA)
         read string SYSTEM_FILE_DATA, dat$
         split string dat$,DATA_NAMEVALSEP
         dataSharedUpdateField(table$, get split word$(1), get split word$(2))
      endwhile
      close file SYSTEM_FILE_DATA


      REM LOAD TEMPLATE CHAIN IF
      REM TEMPLATE KEY IS PRESENT

      alreadyChecked$ = ""
      originalTable$ = table$
      originalFileName$ = filename$

      templateLoaded = 0
      while (dataSharedGetField(table$, DATA_TEMPLATE_KEY, DATA_KEY_UNDEFINED,DATA_NO_CREATE) <> DATA_KEY_UNDEFINED) AND (instr(alreadyChecked$,table$) = 0)
         template$ = dataSharedGetField(table$, DATA_TEMPLATE_KEY, DATA_KEY_UNDEFINED,DATA_NO_CREATE)
         debugWrite(DEBUGINFO, "dataSharedLoadTable: applying template " + template$)
         alreadyChecked$ = systemSharedFieldAdd(alreadyChecked$,template$,DATA_ARGSEP)
         filename$ = DATA_PATH + template$ + DATA_FILE_EXT
         if file exist(filename$)
            open to read SYSTEM_FILE_DATA, filename$
               while not file end(SYSTEM_FILE_DATA)
                  read string SYSTEM_FILE_DATA, dat$
                  split string dat$, DATA_NAMEVALSEP
                  dataSharedUpdateField(originalTable$, get split word$(1), get split word$(2))
                  `debugWrite(DEBUGINFO,"dataSharedLoad template: " + get split word$(1) + " from table " + filename$ + " added to table " + originalTable$)
                  templateLoaded = 1
               endwhile
            close file SYSTEM_FILE_DATA
         else
            debugWrite(DEBUGWARN,"dataSharedLoadTable: table does not exist " + filename$)
         endif
         table$ = template$
      endwhile

      REM RELOAD BASE IF ANY TEMPLATES WERE LOADED
      REM THIS ALLOWS LOCAL VALUES TO OVERRIDE
      REM INHERITED VALUES

      if TemplateLoaded = 1
         open to read SYSTEM_FILE_DATA, originalFileName$
         while not file end(SYSTEM_FILE_DATA)
            read string SYSTEM_FILE_DATA, dat$
            split string dat$,DATA_NAMEVALSEP
            dataSharedUpdateField(originalTable$, get split word$(1), get split word$(2))
         endwhile
         close file SYSTEM_FILE_DATA
      endif


   endif

endfunction retval


function dataSharedSaveAllTables()

   local myTable as integer
   myTable = 1

   debugWrite(DEBUGINFO,"dataSharedSaveAllTables called, skipping: " + DATA_NOSAVE_TABLES)
   if lookup exist(DATA_TABLES)
      FIRST LOOKUP DATA_TABLES
      while lookup is valid(DATA_TABLES)
        myKey$ = LOOKUP CURRENT KEY$(DATA_TABLES)
        if systemSharedFieldInRecord(DATA_NOSAVE_TABLES,myKey$,DATA_ARGSEP) = 0
            filename$ = DATA_PATH + myKey$ + DATA_FILE_EXT
            myTable = intval(LOOKUP CURRENT VALUE$(DATA_TABLES))
            if lookup exist(myTable)
               debugWrite(DEBUGINFO,"dataSharedSaveAllTables saving: " + filename$)
               dataSharedSaveTable(myTable, filename$)
            endif
         endif
         next lookup DATA_TABLES
      endwhile
   endif
   
endfunction

function dataSharedSaveTable(myTable as integer, filename$ as string)
   
   if filename$ <> "" and myTable > 0
   
         if file exist(filename$)
            delete file filename$
         endif
         
         open to write SYSTEM_FILE_DATA, filename$
         FIRST LOOKUP myTable
         while lookup is valid(myTable)
            if LOOKUP CURRENT KEY$(myTable) <> "" AND LOOKUP CURRENT KEY$(myTable) <> DATA_KEY_DIRTY  AND LOOKUP CURRENT KEY$(myTable) <> DATA_KEY_UNDEFINED
               dat$ = LOOKUP CURRENT KEY$(myTable) + DATA_NAMEVALSEP + LOOKUP CURRENT VALUE$(myTable)
               write string SYSTEM_FILE_DATA, dat$
            endif
            next lookup myTable
         endwhile
         close file SYSTEM_FILE_DATA
   
   endif
   
endfunction

function dataSharedTableExist(tableName$ as string)
   local retval as integer
   retval = DATA_FUNCTION_FAIL
   if search lookup (DATA_TABLES, tableName$) = 1
      if lookup is valid(DATA_TABLES)
         retval = intval(LOOKUP CURRENT VALUE$(DATA_TABLES))
      endif
   endif
endfunction retval

